
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Loark 기능 테스트</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        .container { max-width: 800px; margin: auto; }
        .section { margin-bottom: 30px; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        h2 { border-bottom: 2px solid #eee; padding-bottom: 10px; }
        h3 { margin-top: 20px; }
        button { margin: 5px; }
        input[type="text"] { padding: 5px; margin-right: 10px; width: 300px; }
        #userInfo, #friendList, #blockedList, #authCodeDisplay, #verificationResult, #uploadResult { margin-top: 15px; }
        .hidden { display: none; }
        li { list-style-type: none; padding: 5px 0; border-bottom: 1px solid #eee; }
        #authCodeDisplay, #verificationResult, #uploadResult {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            background: #f9f9f9;
            word-wrap: break-word;
        }
        #verified-status { color: green; font-weight: bold; }
        #uploadResult img { max-width: 200px; margin: 5px; border: 1px solid #ccc; }
    </style>
</head>
<body>

<div class="container">
    <h1>Loark 기능 테스트 페이지</h1>

    <div class="section">
        <h2>인증</h2>
        <div id="auth-logged-out">
            <a href="/oauth2/authorization/google"><button>Google로 로그인</button></a>
        </div>
        <div id="auth-logged-in" class="hidden">
            <div id="userInfo"></div>
            <button onclick="logout()">로그아웃</button>
            <hr>
            <h3>로스트아크 계정 인증</h3>

            <div id="stove-verification-process">
                <div id="get-code-step">
                    <p><b>1단계: 인증 코드 발급</b></p>
                    <p>아래 버튼을 눌러 인증 코드를 발급받은 후, 로스트아크 홈페이지 자기소개에 붙여넣어 주세요.</p>
                    <a href="https://profile.onstove.com/" target="_blank"><button>로스트아크 프로필 바로가기</button></a>
                    <button onclick="getAuthCode()">인증 코드 발급받기</button>
                    <div id="authCodeDisplay"></div>
                </div>
                <hr>

                <div id="verify-step">
                    <p><b>2단계: 인증 완료하기</b></p>
                    <p>자기소개를 업데이트한 후, 본인의 프로필 URL을 아래에 붙여넣고 인증 버튼을 누르세요.</p>
                    <input type="text" id="stoveUrlInput" placeholder="https://profile.onstove.com/ko/..." size="50">
                    <button onclick="verifyStove()">인증하기</button>
                    <div id="verificationResult"></div>
                </div>
            </div>

            <div id="verified-status" class="hidden">
                <p>✅ 로스트아크 계정 인증 완료!</p>
                <p>대표 캐릭터: <strong id="mainCharacterDisplay"></strong></p>
            </div>
        </div>
    </div>

    <!-- 이미지 업로드 및 분석 섹션 -->
    <div id="image-upload-section" class="section hidden">
        <h2>레이드 기록 분석</h2>
        <p>분석을 원하는 캐릭터를 선택하고, 레이드 분석 스크린샷을 업로드하여 AI 분석을 요청합니다.</p>

        <!-- 캐릭터 선택 드롭다운 -->
        <div id="character-selection-container" style="margin-bottom: 15px;">
             <label for="characterSelect" style="margin-right: 10px;"><strong>캐릭터 선택:</strong></label>
             <select id="characterSelect" name="characterSelect" style="padding: 5px; min-width: 200px;"></select>
        </div>

        <input type="file" id="imageUploadInput" multiple accept="image/*">
        <button onclick="uploadAndAnalyzeImages()">업로드 및 분석</button>
        <div id="uploadResult"></div>
    </div>

    <div id="friend-section" class="section hidden">
        <h2>친구 관리</h2>
        <div>
            <input type="text" id="friendRequestInput" placeholder="친구 요청할 유저 ID">
            <button onclick="sendFriendRequest()">친구 요청 보내기</button>
        </div>
        <hr>
        <div>
            <button onclick="getFriends('PENDING')">받은 요청</button>
            <button onclick="getFriends('REQUESTED')">보낸 요청</button>
            <button onclick="getFriends('ACCEPTED')">친구 목록</button>
        </div>
        <ul id="friendList"></ul>
    </div>

    <div id="block-section" class="section hidden">
        <h2>사용자 차단</h2>
        <div>
            <input type="text" id="blockUserInput" placeholder="차단할 유저 ID">
            <button onclick="blockUser()">차단하기</button>
        </div>
        <hr>
        <button onclick="getBlockedUsers()">차단 목록 보기 (미구현)</button>
        <ul id="blockedList"></ul>
    </div>

</div>

<script>
    let currentUser = null;

    window.onload = checkAuth;

    async function checkAuth() {
        const response = await fetch('/auth/me');
        const data = await response.json();

        const loggedOutView = document.getElementById('auth-logged-out');
        const loggedInView = document.getElementById('auth-logged-in');
        const imageUploadSection = document.getElementById('image-upload-section');
        const friendSection = document.getElementById('friend-section');
        const blockSection = document.getElementById('block-section');

        if (data.authenticated) {
            currentUser = data;
            loggedOutView.classList.add('hidden');
            loggedInView.classList.remove('hidden');
            
            document.getElementById('userInfo').innerHTML = `
                <p><strong>ID:</strong> ${data.userId}</p>
                <p><strong>이름:</strong> ${data.displayName}</p>
                <p><strong>이메일:</strong> ${data.email}</p>
                <img src="${data.pictureUrl}" alt="Profile Picture" width="50">
            `;

            const verificationProcess = document.getElementById('stove-verification-process');
            const verifiedStatus = document.getElementById('verified-status');

            if (data.mainCharacter) {
                verificationProcess.classList.add('hidden');
                verifiedStatus.classList.remove('hidden');
                document.getElementById('mainCharacterDisplay').textContent = data.mainCharacter;
                // 인증 완료 시에만 업로드, 친구, 차단 섹션 표시
                imageUploadSection.classList.remove('hidden');
                friendSection.classList.remove('hidden');
                blockSection.classList.remove('hidden');

                // 로그인한 유저의 캐릭터 목록 불러오기
                loadUserCharacters();

            } else {
                verificationProcess.classList.remove('hidden');
                verifiedStatus.classList.add('hidden');
            }

        } else {
            currentUser = null;
            loggedOutView.classList.remove('hidden');
            loggedInView.classList.add('hidden');
            imageUploadSection.classList.add('hidden');
            friendSection.classList.add('hidden');
            blockSection.classList.add('hidden');
        }
    }

    async function logout() {
        await fetch('/auth/logout', { method: 'POST' });
        currentUser = null;
        window.location.reload();
    }

    async function getAuthCode() {
        const display = document.getElementById('authCodeDisplay');
        display.innerHTML = '코드를 생성 중입니다...';
        const response = await fetch('/api/auth/code');
        const result = await response.json();

        if (response.ok) {
            display.innerHTML = `생성된 인증 코드: <strong>${result.data}</strong><br>이 코드를 복사하여 로스트아크 자기소개에 붙여넣기 하세요.`;
        } else {
            display.innerHTML = `오류가 발생했습니다: ${result.responseMessage}`;
        }
    }

    async function verifyStove() {
        const stoveUrl = document.getElementById('stoveUrlInput').value;
        const resultDisplay = document.getElementById('verificationResult');

        if (!stoveUrl) {
            resultDisplay.innerHTML = '프로필 URL을 입력해주세요.';
            return;
        }

        resultDisplay.innerHTML = '인증을 진행 중입니다...';

        const response = await fetch('/api/auth/verify', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ stoveUrl: stoveUrl })
        });

        const result = await response.json();

        if (response.ok) {
            resultDisplay.innerHTML = `✅ ${result.responseMessage}<br>대표 캐릭터 <strong>${result.data}</strong> 님이 확인되었습니다. 페이지를 새로고침합니다.`;
            setTimeout(() => window.location.reload(), 2000);
        } else {
            resultDisplay.innerHTML = `❌ 오류: ${result.responseMessage || '알 수 없는 오류'}<br><small>${result.data || ''}</small>`;
        }
    }

    // 사용자의 캐릭터 목록을 불러와 드롭다운에 채우는 함수
    async function loadUserCharacters() {
        const select = document.getElementById('characterSelect');
        try {
            // 백엔드에 캐릭터 목록을 요청하는 API. 경로는 /api/characters로 가정합니다.
            const response = await fetch('/api/characters/list');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const characters = await response.json();
            
            select.innerHTML = ''; // 기존 옵션 초기화

            if (characters && characters.length > 0) {
                characters.forEach(character => {
                    const option = document.createElement('option');
                    // API 응답에 characterName, characterClassName, itemAvgLevel 필드가 있다고 가정합니다.
                    option.value = character.name;
                    option.textContent = `${character.name} (${character.clazz} / ${character.itemLevel} / ${character.combatPower})`;
                    select.appendChild(option);
                });
            } else {
                select.innerHTML = '<option value="">보유한 캐릭터가 없습니다.</option>';
            }
        } catch (error) {
            console.error('캐릭터 목록 로딩 오류:', error);
            select.innerHTML = '<option value="">캐릭터를 불러올 수 없습니다.</option>';
        }
    }

    // 이미지 업로드 및 분석 요청 함수
    async function uploadAndAnalyzeImages() {
        const input = document.getElementById('imageUploadInput');
        const files = input.files;
        const resultDisplay = document.getElementById('uploadResult');
        const characterSelect = document.getElementById('characterSelect');
        const selectedCharacter = characterSelect.value;

        if (!selectedCharacter) {
            resultDisplay.innerHTML = '분석할 캐릭터를 선택해주세요.';
            return;
        }

        if (files.length === 0) {
            resultDisplay.innerHTML = '업로드할 이미지를 선택해주세요.';
            return;
        }

        const formData = new FormData();
        // 선택된 캐릭터 이름을 같이 보냅니다.
        formData.append('characterName', selectedCharacter);
        for (const file of files) {
            formData.append('files', file);
        }

        resultDisplay.innerHTML = `[${selectedCharacter}] 캐릭터의 파일을 업로드하고 AI 분석을 요청합니다...`;

        try {
            const response = await fetch('/api/images/upload', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (response.ok) {
                resultDisplay.innerHTML = `
                    <h3>✅ 분석 완료!</h3>
                    <p>${result.message || '분석 결과가 S3에 저장되었습니다.'}</p>
                    <p><strong>결과 파일 경로:</strong> ${result.s3_json_path || '경로 정보 없음'}</p>
                `;
            } else {
                // FastAPI 등에서 온 상세 오류 메시지 표시
                resultDisplay.innerHTML = `❌ 분석 실패: ${result.detail || result.error || '알 수 없는 오류'}`;
            }
        } catch (error) {
            console.error('Upload/Analysis error:', error);
            resultDisplay.innerHTML = '❌ 요청 처리 중 네트워크 오류가 발생했습니다.';
        }
    }

    // --- (친구 및 차단 관련 함수는 이전과 동일) ---
    async function sendFriendRequest() {
        const targetUserId = document.getElementById('friendRequestInput').value;
        if (!targetUserId) { alert('유저 ID를 입력하세요.'); return; }
        const response = await fetch('/api/friends/request', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ targetUserId: parseInt(targetUserId) })
        });
        alert(await response.text());
        getFriends('REQUESTED');
    }

    async function getFriends(status) {
        const response = await fetch(`/api/friends?status=${status}`);
        const page = await response.json();
        const friends = page.content;
        const listElement = document.getElementById('friendList');
        listElement.innerHTML = '';
        if (friends.length === 0) {
            listElement.innerHTML = '<li>목록이 비었습니다.</li>';
            return;
        }
        friends.forEach(friend => {
            const li = document.createElement('li');
            let buttons = '';
            if (status === 'PENDING') {
                buttons = `<button onclick="acceptRequest(${friend.friendId})">수락</button> <button onclick="declineRequest(${friend.friendId})">거절</button>`;
            } else if (status === 'ACCEPTED') {
                buttons = `<button onclick="deleteFriend(${friend.friendId})">삭제</button>`;
            }
            li.innerHTML = `${friend.otherNickname} (ID: ${friend.otherUserId}) - 상태: ${friend.status} <div>${buttons}</div>`;
            listElement.appendChild(li);
        });
    }

    async function acceptRequest(friendId) {
        const response = await fetch(`/api/friends/requests/${friendId}/accept`, { method: 'POST' });
        alert(await response.text());
        getFriends('PENDING');
    }

    async function declineRequest(friendId) {
        const response = await fetch(`/api/friends/requests/${friendId}/decline`, { method: 'POST' });
        alert(await response.text());
        getFriends('PENDING');
    }

    async function deleteFriend(friendId) {
        const response = await fetch(`/api/friends/${friendId}`, { method: 'DELETE' });
        alert(await response.text());
        getFriends('ACCEPTED');
    }

    async function blockUser() {
        const blockedUserId = document.getElementById('blockUserInput').value;
        if (!blockedUserId) { alert('차단할 유저 ID를 입력하세요.'); return; }
        const response = await fetch('/api/blocks', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ blockedUserId: parseInt(blockedUserId) })
        });
        alert(await response.text());
    }

    function getBlockedUsers() {
        alert('차단 목록을 가져오는 API가 아직 확인되지 않았습니다.');
    }

</script>

</body>
</html>
